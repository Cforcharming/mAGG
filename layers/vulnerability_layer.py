#  Copyright 2022 Hanwen Zhang
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  Unless required by applicable law or agreed to in writing, software.
#  You may obtain a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#  Distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""
Layer for manipulation of the vulnerabilities of services.
Including abstract class VulnerabilityLayer
"""

import os
import json
import time
import shutil
import subprocess
from pathlib import Path
from concurrent.futures import Executor, Future, wait


class VulnerabilityLayer:
    """
    Encapsulation of vulnerabilities of a node, identified by a property called 'image'
    
    Properties:
        exploitable_vulnerabilities: processed vulnerabilities with NVD attack vectors that are exploitable
        
        scores: CVSS scores for vulnerabilities
    """
    
    def __init__(self, example_folder: str, services: dict[str, dict[str]],
                 config: dict, attack_vectors: dict[str, dict[str]]):
        """
        Initialise a vulnerability layer
        """
        self._vulnerabilities = None
        self._parsed_images = None
        self._exploitable_vulnerabilities = {}
        self._scores = {}
        self._services = services
        self._config = config
        self._attack_vectors = attack_vectors
        self._example_folder = example_folder

        if go_path := os.getenv('GOPATH') is None:
            go_path = os.path.join(str(Path.home()), 'go')

        self.clairctl_home = os.path.join(go_path, 'src/github.com/jgsqware/clairctl')

        if not os.path.exists(self.clairctl_home):
            raise EnvironmentError(
                'Go environment not detected, or clairctl environment not exists in:\n' + self.clairctl_home)

        dv = self.__parse_vulnerabilities()
        dvp = self.__get_exploitable_vulnerabilities()

        print('\nTime for vulnerability parser module:', dv + dvp, 'seconds.')
    
    @property
    def exploitable_vulnerabilities(self) -> dict[str, dict[str, dict]]:
        """
        Returns:
            exploitable_vulnerabilities: processed vulnerabilities with NVD attack vectors that are exploitable
        """
        return self._exploitable_vulnerabilities
    
    @property
    def scores(self) -> dict[str, int]:
        """
        Returns:
            scores: CVSS scores for vulnerabilities
        """
        return self._scores
    
    @exploitable_vulnerabilities.setter
    def exploitable_vulnerabilities(self, exploitable_vulnerabilities: dict[str, dict[str, dict]]):
        self._exploitable_vulnerabilities = exploitable_vulnerabilities
    
    @scores.setter
    def scores(self, scores: dict[str, int]):
        self._scores = scores
    
    @staticmethod
    def get_attack_vectors(attack_vector_path: str, executor: Executor) -> dict[str, dict[str]]:
        """
        Load NVD JSON Feeds concurrently.
        Parameters:
            attack_vector_path: folder containing NVD files
            executor: concurrent.future.Executor. If is not None, try to run concurrently
        Returns:
            Attack vectors in forms of dictionary
        """
        # Initializing the attack vector dictionary.
        attack_vectors: dict[str, dict[str]] = dict()
        attack_vector_filenames = os.listdir(attack_vector_path)
        futures: list[Future] = list()
    
        # Iterating through the attack vector files.
        for attack_vector_filename in attack_vector_filenames:
            # Load the attack vector.
            if not attack_vector_filename.startswith("nvdcve"):
                continue
        
            if executor is not None:
                future = executor.submit(read_att_vectors, attack_vector_path, attack_vector_filename)
                future.add_done_callback(VulnerabilityLayer.__add_vec_to_list(attack_vectors))
                futures.append(future)
            else:
                attack_vectors.update(read_att_vectors(attack_vector_path, attack_vector_filename))
    
        if executor is not None:
            wait(futures)
    
        return attack_vectors

    @staticmethod
    def get_privilege_str(privilege: int) -> str:
        """
        Convert int privilege to str
        Parameters:
            privilege: int privilege
        Returns:
            str privilege
        """
    
        mapping = {0: "NONE", 1: "VOS USER", 2: "VOS ADMIN", 3: "USER", 4: "ADMIN"}
    
        return mapping[privilege]

    @staticmethod
    def get_privilege_value(privilege: str) -> int:
        """
        Convert str privilege to int
        Parameters:
            privilege: int privilege
        Returns:
            str privilege
        """
    
        mapping = {"NONE": 0, "VOS USER": 1, "VOS ADMIN": 2, "USER": 3, "ADMIN": 4}
    
        return mapping[privilege]
    
    def add_image(self, image: str):
        """
        Parsing vulnerabilities for a new image
        Parameters:
            image: name of image
        """
        if image not in self._vulnerabilities:
            self._vulnerabilities[image] = self.__get_single_vulnerability(image)
    
    def __parse_vulnerabilities(self) -> float:
        """Function that gets the vulnerabilities for each docker container."""
        
        self.__cache_parsed_images()
        self._vulnerabilities = dict()
        
        print('Vulnerabilities parsing started.')
        
        time_start = time.time()
        
        for service in self._services:
            
            image = self._services[service]['image']
            
            if image not in self._vulnerabilities:
                vulnerability = self.__get_single_vulnerability(image)
                self._vulnerabilities[image] = vulnerability
        
        dv = time.time() - time_start
        print('Time for getting vulnerabilities in services:', dv, 'seconds.')
        
        return dv
    
    def __get_exploitable_vulnerabilities(self) -> float:
        
        time_start = time.time()
        print('Pre-processing vulnerabilities started.')
        
        pre_rules = self._config["preconditions-rules"]
        post_rules = self._config["postconditions-rules"]
        single_label = self._config['single-edge-label']
        
        # Getting the potentially exploitable vulnerabilities for each container.
        for name in self._services:
            image = self._services[name]['image']
            if name != "outside" and name not in self.exploitable_vulnerabilities:
                # Reading the vulnerability
                exploit_ability_dict, vulnerability_scores = \
                    get_image_exploitable_vulnerabilities(self._vulnerabilities[image], self._attack_vectors, pre_rules,
                                                          post_rules, single_label)
                self.exploitable_vulnerabilities[name] = exploit_ability_dict
                self.scores |= vulnerability_scores
        
        dvp = time.time() - time_start
        print('Time for vulnerabilities pre-processing:', dvp, 'seconds.')
        
        return dvp

    def __cache_parsed_images(self):
    
        files = os.listdir(self._example_folder)
        self._parsed_images = set()
    
        for file in files:
            if 'vulnerabilities' in file:
                image = file.replace('-vulnerabilities.json', '')
                self._parsed_images.add(image)
    
    def __get_single_vulnerability(self, image: str) -> dict[str]:
        self.__parse_single_image(image)
        vulnerability_path = os.path.join(self._example_folder, image + "-vulnerabilities.json")
        with open(vulnerability_path) as vul_file:
            vulnerability_json = json.load(vul_file)
        return vulnerability_json
    
    @staticmethod
    def __add_vec_to_list(attack_vectors: dict[str, dict[str]]):
        def cbs(future: Future):
            attack_vectors.update(future.result())
        return cbs
    
    def __parse_single_image(self, image: str):
        if image not in self._parsed_images:
            print("Making report for the image " + image)
            
            if not os.path.exists(
                    os.path.join(self.clairctl_home, "docker-compose-data",
                                 "clairctl-reports", "json", "analysis-" + image + "-latest.json")):
                old_root_path = os.getcwd()
                os.chdir(self.clairctl_home)
                subprocess.call(
                    ["docker", "compose", "exec", "--user", "root", "clairctl", "clairctl", "--no-clean", "report",
                     "--local", "--format", "json", image], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
                os.chdir(old_root_path)
            
            self.__copy_vulnerability_file(image)
            self._parsed_images.add(image)
    
    def __copy_vulnerability_file(self, image: str):
        """Copies the vulnerability file from clairctl to the local location."""
        
        json_name = os.path.join(self._example_folder, image + "-vulnerabilities.json")
        
        shutil.copy(os.path.join(self.clairctl_home, "docker-compose-data", "clairctl-reports", "json", "analysis-"
                                 + image + "-latest.json"), json_name)


def read_att_vectors(attack_vector_folder_path: str, attack_vector_filename: str) -> dict[str, dict[str]]:
    with open(os.path.join(attack_vector_folder_path, attack_vector_filename)) as att_vec:
        print('Reading NVD feed file:', attack_vector_filename, flush=True)
        attack_vector_file = json.load(att_vec)
        
        file_attack_vectors = dict()
        
        # Load the attack vector.
        cve_items = attack_vector_file["CVE_Items"]
        
        # Filtering only the important information and creating the dictionary.
        for cve_item in cve_items:
            dictionary_cve = {"attack_vec": "?", "desc": "?", "cpe": "?"}
            # Getting the attack vector and the description.
            
            cve_id = cve_item["cve"]["CVE_data_meta"]["ID"]
            
            if "baseMetricV3" in cve_item["impact"]:
                dictionary_cve["attack_vec"] = cve_item["impact"]["baseMetricV3"]["cvssV3"]["vectorString"]
            elif "baseMetricV2" in cve_item["impact"]:
                dictionary_cve["attack_vec"] = cve_item["impact"]["baseMetricV2"]["cvssV2"]["vectorString"]
            
            if "description" in cve_item["cve"]:
                descr = cve_item["cve"]["description"]["description_data"][0]['value']
                dictionary_cve["desc"] = descr
            else:
                cve_id = None
            
            # Get the CPE values: a - application, o - operating system and h - hardware
            nodes = cve_item["configurations"]["nodes"]
            if len(nodes) > 0:
                if "cpe" in nodes[0]:
                    cpe = cve_item["configurations"]["nodes"][0]["cpe"][0]["cpe23Uri"]
                    dictionary_cve["cpe"] = cpe
                
                elif "cpe_match" in nodes[0]:
                    if len(cve_item["configurations"]["nodes"][0]["cpe_match"]) > 0:
                        cpe = cve_item["configurations"]["nodes"][0]["cpe_match"][0]["cpe23Uri"]
                        dictionary_cve["cpe"] = cpe
                
                else:
                    if "children" in nodes[0]:
                        children = nodes[0]["children"]
                        if len(children) > 0 and "cpe" in children[0]:
                            cpe = children[0]["cpe"][0]["cpe22Uri"]
                            dictionary_cve["cpe"] = cpe
            
            if dictionary_cve["cpe"] != "?":
                dictionary_cve["cpe"] = dictionary_cve["cpe"][5]
            file_attack_vectors[cve_id] = dictionary_cve
    
    return file_attack_vectors


def get_image_exploitable_vulnerabilities(vulnerabilities: dict[str], attack_vectors: dict[str, dict[str]],
                                          pre_rules: dict[str, dict[str]], post_rules: dict[str, dict[str]],
                                          single=True) -> (dict[str, dict[str, int]], dict[str, int]):
    """Processes and provides exploitable vulnerabilities per container."""
    
    # Remove junk and just take the most important part from each vulnerability
    cleaned_vulnerabilities, vulnerability_scores = clean_vulnerabilities(vulnerabilities)
    
    # Merging the cleaned vulnerabilities
    merged_vulnerabilities = merge_attack_vector_vulnerabilities(attack_vectors, cleaned_vulnerabilities)
    
    # Get the preconditions and postconditions for each vulnerability.
    pre_conditions, post_conditions = rule_processing(merged_vulnerabilities, pre_rules, post_rules)
    
    exploit_ability_dict = {"precond": pre_conditions, "postcond": post_conditions}
    
    reverse_exploitable: dict[str, dict[int, list[str]]] = {'pre': {0: [], 1: [], 2: [], 3: [], 4: []},
                                                            'post': {0: [], 1: [], 2: [], 3: [], 4: []}}
    
    for vulnerability in pre_conditions:
        
        pre_privilege: int = pre_conditions[vulnerability]
        post_privilege: int = post_conditions[vulnerability]
        
        if single:
            len_pre = len(reverse_exploitable['pre'][pre_privilege])
            if len_pre == 1:
                if vulnerability > reverse_exploitable['pre'][pre_privilege][0]:
                    reverse_exploitable['pre'][pre_privilege] = [vulnerability]
            else:
                reverse_exploitable['pre'][pre_privilege] = [vulnerability]
            
            len_post = len(reverse_exploitable['post'][post_privilege])
            if len_post == 1:
                if vulnerability > reverse_exploitable['post'][post_privilege][0]:
                    reverse_exploitable['post'][post_privilege] = [vulnerability]
            else:
                reverse_exploitable['post'][post_privilege] = [vulnerability]
        else:
            reverse_exploitable['pre'][pre_privilege].append(vulnerability)
            reverse_exploitable['post'][post_privilege].append(vulnerability)
    
    exploit_ability_dict |= reverse_exploitable
    
    return exploit_ability_dict, vulnerability_scores


def clean_vulnerabilities(raw_vulnerabilities: dict[str]) -> (dict[str, dict[str]], dict[str, int]):
    """Cleans the vulnerabilities for a given container."""
    
    cleaned_vulnerabilities = {}
    vulnerability_scores: dict[str, int] = dict()
    
    # Going to the .json hierarchy to get the CVE IDs.
    layers = raw_vulnerabilities["Layers"]
    for layer in layers:
        features = layer["Layer"]["Features"]
        for feature in features:
            if "Vulnerabilities" not in feature:
                continue
            
            vulnerabilities_structure = feature["Vulnerabilities"]
            for vulnerability in vulnerabilities_structure:
                vulnerability_new = {}
                # Finding the description
                if "Description" in vulnerability.keys():
                    vulnerability_new["desc"] = vulnerability["Description"]
                else:
                    vulnerability_new["desc"] = "?"
                
                # Finding the attack vector
                vulnerability_new["attack_vec"] = "?"
                if "Metadata" in vulnerability.keys():
                    metadata = vulnerability["Metadata"]
                    if "NVD" not in metadata:
                        continue
                    
                    if 'CVSSv3' in metadata['NVD']:
                        cvss = metadata['NVD']['CVSSv3']
                    elif 'CVSSv2' in metadata['NVD']:
                        cvss = metadata['NVD']['CVSSv2']
                    else:
                        continue
                    
                    score = cvss['Score']
                    vec = cvss['Vectors']
                    
                    vulnerability_new["attack_vec"] = vec
                    vulnerability_scores[vulnerability['Name']] = score
                    cleaned_vulnerabilities[vulnerability["Name"]] = vulnerability_new
    
    return cleaned_vulnerabilities, vulnerability_scores


def merge_attack_vector_vulnerabilities(attack_vector_dict, vulnerabilities):
    """Merging the information from vulnerabilities and the attack vector files."""
    
    merged_vulnerabilities = {}
    
    for vulnerability in vulnerabilities:
        vulnerability_new = {}
        if vulnerability in attack_vector_dict:
            
            vulnerability_new["desc"] = attack_vector_dict[vulnerability]["desc"]
            
            if attack_vector_dict[vulnerability]["attack_vec"] != "?":
                av_string = attack_vector_dict[vulnerability]["attack_vec"]
                attack_vec = attack_vector_string_to_dict(av_string)
                vulnerability_new["attack_vec"] = attack_vec
            vulnerability_new["cpe"] = attack_vector_dict[vulnerability]["cpe"]
        
        else:
            
            vulnerability_new["desc"] = vulnerabilities[vulnerability]["desc"]
            if vulnerabilities[vulnerability]["attack_vec"] != "?":
                av_string = vulnerabilities[vulnerability]["attack_vec"]
                attack_vec = attack_vector_string_to_dict(av_string)
                vulnerability_new["attack_vec"] = attack_vec
            
            vulnerability_new["cpe"] = "?"
        
        merged_vulnerabilities[vulnerability] = vulnerability_new
    
    return merged_vulnerabilities


def attack_vector_string_to_dict(av_string):
    """Transforms the attack vector string to dictionary."""
    
    av_dict = {}
    
    # Remove brackets.
    if av_string[0] == "(":
        av_string = av_string[1:len(av_string) - 1]
    
    # Put structure into dictionary
    categories = av_string.split("/")
    for category in categories:
        parts = category.split(":")
        av_dict[parts[0]] = parts[1]
    
    return av_dict


def rule_processing(merged_vulnerability, pre_rules, post_rules):
    """ This function is responsible for creating the
    precondition and post-condition rules."""
    
    pre_conditions = dict()
    post_conditions = dict()
    for vulnerability_key in merged_vulnerability:
        vulnerability = merged_vulnerability[vulnerability_key]
        
        if "attack_vec" not in vulnerability or vulnerability["attack_vec"] == "?":
            continue
        for pre_rule in pre_rules:
            rule = pre_rules[pre_rule]
            pre_conditions = get_rule_precondition(rule, vulnerability, pre_conditions, vulnerability_key)
        
        for post_rule in post_rules:
            rule = post_rules[post_rule]
            post_conditions = get_post_condition_from_rule(rule, vulnerability, post_conditions, vulnerability_key)
        
        # Assign default values if rules are undefined
        if vulnerability_key not in pre_conditions:
            pre_conditions[vulnerability_key] = 0  # 0 is None level
        if vulnerability_key not in post_conditions:
            post_conditions[vulnerability_key] = 4  # 4 is Admin level
    
    return pre_conditions, post_conditions


def get_rule_precondition(rule, vul, pre_conditions, vul_key):
    """Checks if it finds rule precondition"""
    
    # Checks if the cpe in the rule is same with vulnerability.
    if rule["cpe"] != "?":
        if rule["cpe"] == "o" and vul["cpe"] != "o":
            return pre_conditions
        elif rule["cpe"] == "h" and (vul["cpe"] != "h" and vul["cpe"] != "a"):
            return pre_conditions
    
    # Checks if the vocabulary is matching
    if "vocabulary" in rule.keys():
        hit_vocab = get_hit_vocabulary(rule, vul)
        if hit_vocab and \
                (vul_key not in pre_conditions or pre_conditions[vul_key]
                 < VulnerabilityLayer.get_privilege_value(rule["precondition"])):
            pre_conditions[vul_key] = VulnerabilityLayer.get_privilege_value(rule["precondition"])
    
    # Check access vector
    else:
        if rule["accessVector"] != "?":
            
            if rule["accessVector"] == "LOCAL" and vul["attack_vec"]["AV"] != "L":
                return pre_conditions
            elif vul["attack_vec"]["AV"] != "A" and vul["attack_vec"]["AV"] != "N":
                return pre_conditions
        
        if rule["authentication"] != "?":
            if rule["authentication"] == "NONE" and vul["attack_vec"]["Au"] != "N":
                return pre_conditions
            elif vul["attack_vec"]["Au"] != "L" and vul["attack_vec"]["Au"] != "H":
                return pre_conditions
        
        if rule["accessComplexity"][0] == vul["attack_vec"]["AC"] and \
                (vul_key not in pre_conditions or pre_conditions[vul_key]
                 < VulnerabilityLayer.get_privilege_value(rule["precondition"])):
            pre_conditions[vul_key] = VulnerabilityLayer.get_privilege_value(rule["precondition"])
    
    return pre_conditions


def get_hit_vocabulary(rule, vulnerability):
    sentences = rule["vocabulary"]
    hit_vocabulary = False
    for sentence in sentences:
        if "..." in sentence:
            parts = sentence.split("...")
            if parts[0] in vulnerability["desc"] and parts[1] in vulnerability["desc"]:
                hit_vocabulary = True
                break
        elif "?" == sentence:
            hit_vocabulary = True
            break
        elif sentence in vulnerability["desc"]:
            hit_vocabulary = True
            break
    return hit_vocabulary


def get_post_condition_from_rule(rule, vulnerability, post_condition, vulnerability_key):
    """Checks if it finds rule post-condition"""
    
    # Checks if the cpe in the rule is same with vulnerability.
    if rule["cpe"] != "?":
        if rule["cpe"] == "o" and vulnerability["cpe"] != "o":
            return post_condition
        elif rule["cpe"] == "h" and (vulnerability["cpe"] != "h" and vulnerability["cpe"] != "a"):
            return post_condition
    
    # Checks if the vocabulary is matching
    hit_vocabulary = get_hit_vocabulary(rule, vulnerability)
    if not hit_vocabulary:
        return post_condition
    
    # Check Impacts
    if rule["impacts"] == "ALL_COMPLETE":
        if vulnerability["attack_vec"]["I"] == "C" and vulnerability["attack_vec"]["C"] == "C":
            if vulnerability_key not in post_condition or \
                    post_condition[vulnerability_key] \
                    > VulnerabilityLayer.get_privilege_value(rule["postcondition"]):
                post_condition[vulnerability_key] = VulnerabilityLayer.get_privilege_value(rule["postcondition"])
    
    elif rule["impacts"] == "PARTIAL":
        
        if vulnerability["attack_vec"]["I"] == "P" or vulnerability["attack_vec"]["C"] == "P":
            if vulnerability_key not in post_condition or \
                    post_condition[vulnerability_key] \
                    > VulnerabilityLayer.get_privilege_value(rule["postcondition"]):
                post_condition[vulnerability_key] = VulnerabilityLayer.get_privilege_value(rule["postcondition"])
        
        else:
            if vulnerability_key not in post_condition or \
                    post_condition[vulnerability_key] \
                    > VulnerabilityLayer.get_privilege_value(rule["postcondition"]):
                post_condition[vulnerability_key] = VulnerabilityLayer.get_privilege_value(rule["postcondition"])
    
    elif rule["impacts"] == "ANY_NONE":
        if vulnerability["attack_vec"]["I"] == "N" or vulnerability["attack_vec"]["C"] == "N":
            if vulnerability_key not in post_condition or \
                    post_condition[vulnerability_key] \
                    > VulnerabilityLayer.get_privilege_value(rule["postcondition"]):
                post_condition[vulnerability_key] = VulnerabilityLayer.get_privilege_value(rule["postcondition"])
    
    return post_condition
