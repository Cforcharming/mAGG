"""Module responsible for generating vulnerabilities from docker containers."""

import os
import sys
import json
import time
import errno
import shutil
import subprocess
from pathlib import Path
from concurrent.futures import Executor, Future, wait

from mio.wrapper import is_interactive

if go_path := os.getenv('GOPATH') is None:
    go_path = os.path.join(str(Path.home()), 'go')

clairctl_home = os.path.join(go_path, 'src/github.com/jgsqware/clairctl')

if not os.path.exists(clairctl_home):
    raise EnvironmentError('Go environment not detected, or clairctl environment not exists in:\n' + clairctl_home)


def parse_vulnerabilities(example_folder: str, services: dict[str, dict[str, ]]) \
        -> (int, dict[str, dict[str, ]], set[str], int):
    """Function that gets the vulnerabilities for each docker container."""

    parsed_images = cache_parsed_images(example_folder)
    vulnerabilities = dict()
    
    print("Getting vulnerabilities in services started.")

    time_start = time.time()
    
    for service in services:
        
        image = services[service]['image']
        
        if image not in vulnerabilities:
            vulnerability_json = get_single_vulnerability(parsed_images, example_folder, image)
            vulnerabilities[image] = vulnerability_json
    
    dv = time.time() - time_start
    print('Time for getting vulnerabilities in services:', dv, 'seconds.')
    stat = 0
    if not vulnerabilities.keys():
        print("Found 0 vulnerabilities. Terminating the function...")
        stat = errno.ENOENT
    
    return stat, vulnerabilities, parsed_images, dv


def get_exploitable_vulnerabilities(services: dict[str, dict[str, ]], vulnerabilities: dict[str, dict[str, ]],
                                    pre_rules: dict[str, dict[str, ]], post_rules: dict[str, dict[str, ]],
                                    attack_vectors: dict[str, dict[str, ]], exploitable_vulnerabilities=None) \
        -> (dict[str, dict[str, dict[str, int]]], int):
    
    time_start = time.time()
    print('Pre-processing vulnerabilities started.')
    
    # Getting the potentially exploitable vulnerabilities for each container.
    
    if exploitable_vulnerabilities is None:
        init = True
        exploitable_vulnerabilities = {}
    else:
        init = False
    
    for name in services:
        image = services[name]['image']
        if name != "outside" and exploitable_vulnerabilities.get(name) is None:
            # Reading the vulnerability
            exploitable_vulnerabilities[name] = get_image_exploitable_vulnerabilities(vulnerabilities[image],
                                                                                      attack_vectors, pre_rules,
                                                                                      post_rules)
    
    dvp = time.time() - time_start
    print('Time for vulnerabilities pre-processing:', dvp, 'seconds.')
    
    if init:
        return exploitable_vulnerabilities, dvp


def add(config: dict, services: dict[str, dict[str, ]], vulnerabilities: dict[str, dict[str, ]],
        attack_vectors: dict[str, dict[str, ]], exploitable_vulnerabilities: dict[str, dict[str, dict[str, int]]],
        parsed_images: set[str], example_folder: str, image: str):
    
    if image not in vulnerabilities:
        vulnerabilities[image] = get_single_vulnerability(parsed_images, example_folder, image)

    get_exploitable_vulnerabilities(services, vulnerabilities, config["preconditions-rules"],
                                    config["postconditions-rules"], attack_vectors, exploitable_vulnerabilities)
        

def get_privilege_level(privilege: int) -> str:
    """Mapping the value to the privilege level for easier readability in the attack graph."""
    
    mapping = {0: "NONE", 1: "VOS USER", 2: "VOS ADMIN", 3: "USER", 4: "ADMIN"}
    
    return mapping[privilege]


def get_privilege_value(privilege_level: str) -> int:
    """Mapping the privilege level to its value, so that it can be compared later."""
    
    mapping = {"NONE": 0, "VOS USER": 1, "VOS ADMIN": 2, "USER": 3, "ADMIN": 4}
    
    return mapping[privilege_level]


def cache_parsed_images(example_folder: str) -> set[str]:
    files = os.listdir(example_folder)
    
    parsed_images = set()
    
    for file in files:
        if 'vulnerabilities' in file:
            image = file.replace('-vulnerabilities.json', '')
            parsed_images.add(image)
    
    return parsed_images


def get_single_vulnerability(parsed_images: set[str], example_folder: str, image: str) -> dict[str, ]:
    parse_single_image(parsed_images, image, example_folder)
    vulnerability_path = os.path.join(example_folder, image + "-vulnerabilities.json")
    with open(vulnerability_path) as vul_file:
        vulnerability_json = json.load(vul_file)
    return vulnerability_json


def parse_single_image(parsed_images: set[str], image: str, example_folder: str):
    if image not in parsed_images:
        print("Making report for the image " + image)
        
        if not os.path.exists(
                os.path.join(clairctl_home, "docker-compose-data", "clairctl-reports", "json", "analysis-" +
                                                                                               image + "-latest.json")):
            
            old_root_path = os.getcwd()
            os.chdir(clairctl_home)
            subprocess.call(
                ["docker", "compose", "exec", "--user", "root", "clairctl", "clairctl", "--no-clean", "report",
                 "--local", "--format", "json", image], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            os.chdir(old_root_path)
        
        copy_vulnerability_file(image, example_folder)
        parsed_images.add(image)


def copy_vulnerability_file(image: str, example_folder: str):
    """Copies the vulnerability file from clairctl to the local location."""
    
    json_name = os.path.join(example_folder, image + "-vulnerabilities.json")
    
    shutil.copy(os.path.join(clairctl_home, "docker-compose-data", "clairctl-reports", "json", "analysis-" + image
                             + "-latest.json"), json_name)


def get_attack_vectors(attack_vector_path: str, executor: Executor) -> dict[str, dict[str, ]]:
    """Merging the attack vector files into a dictionary."""
    
    # Read the attack vector files.
    attack_vector_files: list[dict[str, ]] = read_attack_vector_files(attack_vector_path, executor)
    
    # Initializing the attack vector dictionary.
    attack_vectors = dict()
    
    count = 0
    # Iterating through the attack vector files.
    for attack_vector_file in attack_vector_files:
        
        # Load the attack vector.
        cve_items = attack_vector_file["CVE_Items"]
        
        # Filtering only the important information and creating the dictionary.
        for cve_item in cve_items:
            dictionary_cve = {"attack_vec": "?", "desc": "?", "cpe": "?"}
            # Getting the attack vector and the description.
            if "baseMetricV2" in cve_item["impact"]:
                
                cve_id = cve_item["cve"]["CVE_data_meta"]["ID"]
                
                cve_attack_vector = cve_item["impact"]["baseMetricV2"]["cvssV2"]["vectorString"]
                dictionary_cve["attack_vec"] = cve_attack_vector
                
                if "description" in cve_item["cve"]:
                    descr = cve_item["cve"]["description"]["description_data"][0]['value']
                    dictionary_cve["desc"] = descr
            else:
                cve_id = None
            
            # Get the CPE values: a - application, o - operating system and h - hardware
            nodes = cve_item["configurations"]["nodes"]
            if len(nodes) > 0:
                if "cpe" in nodes[0]:
                    cpe = cve_item["configurations"]["nodes"][0]["cpe"][0]["cpe22Uri"]
                    dictionary_cve["cpe"] = cpe
                    count = count + 1
                else:
                    if "children" in nodes[0]:
                        children = nodes[0]["children"]
                        if len(children) > 0 and "cpe" in children[0]:
                            cpe = children[0]["cpe"][0]["cpe22Uri"]
                            dictionary_cve["cpe"] = cpe
                            count = count + 1
            
            if dictionary_cve["cpe"] != "?":
                dictionary_cve["cpe"] = dictionary_cve["cpe"][5]
            attack_vectors[cve_id] = dictionary_cve
    return attack_vectors


def read_attack_vector_files(attack_vector_folder_path: str, executor: Executor) -> list[dict[str, ]]:
    """It reads the attack vector files."""
    
    attack_vector_list = []
    
    attack_vector_filenames = os.listdir(attack_vector_folder_path)
    
    futures: list[Future] = list()
    
    # Iterating through the attack vector files.
    for attack_vector_filename in attack_vector_filenames:
        # Load the attack vector.
        if not attack_vector_filename.startswith("nvdcve"):
            continue
        if not is_interactive():
            future = executor.submit(read_att_vec, attack_vector_folder_path, attack_vector_filename)
            future.add_done_callback(add_vec_to_list(attack_vector_list))
            futures.append(future)
        else:
            attack_vector_list.append(read_att_vec(attack_vector_folder_path, attack_vector_filename))

    if not is_interactive():
        wait(futures)
            
    return attack_vector_list


def add_vec_to_list(attack_vector_list: list[dict[str, ]]):
    def cbs(future: Future):
        attack_vector_list.append(future.result())
    return cbs


def read_att_vec(attack_vector_folder_path: str, attack_vector_filename: str):
    with open(os.path.join(attack_vector_folder_path, attack_vector_filename)) as att_vec:
        print('Reading NVD feed file:', attack_vector_filename)
        return json.load(att_vec)


def get_image_exploitable_vulnerabilities(vulnerabilities: dict[str, ], attack_vectors: dict[str, dict[str, ]],
                                          pre_rules: dict[str, dict[str, ]], post_rules: dict[str, dict[str, ]]):
    """Processes and provides exploitable vulnerabilities per container."""
    
    # Remove junk and just take the most important part from each vulnerability
    cleaned_vulnerabilities = clean_vulnerabilities(vulnerabilities)
    
    # Merging the cleaned vulnerabilities
    merged_vulnerabilities = merge_attack_vector_vulnerabilities(attack_vectors, cleaned_vulnerabilities)
    
    # Get the preconditions and postconditions for each vulnerability.
    pre_conditions, post_conditions = rule_processing(merged_vulnerabilities, pre_rules, post_rules)
    exploit_ability_dict = {"precond": pre_conditions, "postcond": post_conditions}
    
    return exploit_ability_dict


def clean_vulnerabilities(raw_vulnerabilities: dict[str, ]) -> dict[str, dict[str, ]]:
    """Cleans the vulnerabilities for a given container."""
    
    cleaned_vulnerabilities = {}
    
    # Going to the .json hierarchy to get the CVE ids.
    layers = raw_vulnerabilities["Layers"]
    for layer in layers:
        features = layer["Layer"]["Features"]
        for feature in features:
            if "Vulnerabilities" not in feature:
                continue
            
            vulnerabilities_structure = feature["Vulnerabilities"]
            for vulnerability in vulnerabilities_structure:
                vulnerability_new = {}
                
                # Finding the description
                if "Description" in vulnerability.keys():
                    vulnerability_new["desc"] = vulnerability["Description"]
                else:
                    vulnerability_new["desc"] = "?"
                
                # Finding the attack vector
                vulnerability_new["attack_vec"] = "?"
                if "Metadata" in vulnerability.keys():
                    metadata = vulnerability["Metadata"]
                    if "NVD" not in metadata:
                        continue
                    
                    if "CVSSv2" not in metadata["NVD"]:
                        continue
                    
                    if "Vectors" in metadata["NVD"]["CVSSv2"]:
                        vec = metadata["NVD"]["CVSSv2"]["Vectors"]
                        vulnerability_new["attack_vec"] = vec
                cleaned_vulnerabilities[vulnerability["Name"]] = vulnerability_new
    
    return cleaned_vulnerabilities


def merge_attack_vector_vulnerabilities(attack_vector_dict, vulnerabilities):
    """Merging the information from vulnerabilities and the attack vector files."""
    
    merged_vulnerabilities = {}
    
    for vulnerability in vulnerabilities:
        vulnerability_new = {}
        if vulnerability in attack_vector_dict:
            
            vulnerability_new["desc"] = attack_vector_dict[vulnerability]["desc"]
            
            if attack_vector_dict[vulnerability]["attack_vec"] != "?":
                av_string = attack_vector_dict[vulnerability]["attack_vec"]
                attack_vec = attack_vector_string_to_dict(av_string)
                vulnerability_new["attack_vec"] = attack_vec
            vulnerability_new["cpe"] = attack_vector_dict[vulnerability]["cpe"]
        
        else:
            
            vulnerability_new["desc"] = vulnerabilities[vulnerability]["desc"]
            if vulnerabilities[vulnerability]["attack_vec"] != "?":
                av_string = vulnerabilities[vulnerability]["attack_vec"]
                attack_vec = attack_vector_string_to_dict(av_string)
                vulnerability_new["attack_vec"] = attack_vec
            
            vulnerability_new["cpe"] = "?"
        
        merged_vulnerabilities[vulnerability] = vulnerability_new
    
    return merged_vulnerabilities


def attack_vector_string_to_dict(av_string):
    """Transforms the attack vector string to dictionary."""
    
    av_dict = {}
    
    # Remove brackets.
    if av_string[0] == "(":
        av_string = av_string[1:len(av_string) - 1]
    
    # Put structure into dictionary
    categories = av_string.split("/")
    for category in categories:
        parts = category.split(":")
        av_dict[parts[0]] = parts[1]
    
    return av_dict


def rule_processing(merged_vulnerability, pre_rules, post_rules):
    """ This function is responsible for creating the
    precondition and post-condition rules."""
    
    pre_conditions = dict()
    post_conditions = dict()
    for vulnerability_key in merged_vulnerability:
        vulnerability = merged_vulnerability[vulnerability_key]
        
        if "attack_vec" not in vulnerability or vulnerability["attack_vec"] == "?":
            continue
        for pre_rule in pre_rules:
            rule = pre_rules[pre_rule]
            pre_conditions = get_rule_precondition(rule, vulnerability, pre_conditions, vulnerability_key)
        
        for post_rule in post_rules:
            rule = post_rules[post_rule]
            post_conditions = get_post_condition_from_rule(rule, vulnerability, post_conditions, vulnerability_key)
        
        # Assign default values if rules are undefined
        if vulnerability_key not in pre_conditions:
            pre_conditions[vulnerability_key] = 0  # 0 is None level
        if vulnerability_key not in post_conditions:
            post_conditions[vulnerability_key] = 4  # 4 is Admin level
    
    return pre_conditions, post_conditions


def get_rule_precondition(rule, vul, pre_conditions, vul_key):
    """Checks if it finds rule precondition"""
    
    # Checks if the cpe in the rule is same with vulnerability.
    if rule["cpe"] != "?":
        if rule["cpe"] == "o" and vul["cpe"] != "o":
            return pre_conditions
        elif rule["cpe"] == "h" and (vul["cpe"] != "h" and vul["cpe"] != "a"):
            return pre_conditions
    
    # Checks if the vocabulary is matching
    if "vocabulary" in rule.keys():
        hit_vocab = get_hit_vocabulary(rule, vul)
        if hit_vocab and \
                (vul_key not in pre_conditions or pre_conditions[vul_key] < get_privilege_value(rule["precondition"])):
            pre_conditions[vul_key] = get_privilege_value(rule["precondition"])
    
    # Check access vector
    else:
        if rule["accessVector"] != "?":
            
            if rule["accessVector"] == "LOCAL" and vul["attack_vec"]["AV"] != "L":
                return pre_conditions
            elif vul["attack_vec"]["AV"] != "A" and vul["attack_vec"]["AV"] != "N":
                return pre_conditions
        
        if rule["authentication"] != "?":
            if rule["authentication"] == "NONE" and vul["attack_vec"]["Au"] != "N":
                return pre_conditions
            elif vul["attack_vec"]["Au"] != "L" and vul["attack_vec"]["Au"] != "H":
                return pre_conditions
        
        if rule["accessComplexity"][0] == vul["attack_vec"]["AC"] and \
                (vul_key not in pre_conditions or pre_conditions[vul_key] < get_privilege_value(rule["precondition"])):
            pre_conditions[vul_key] = get_privilege_value(rule["precondition"])
    
    return pre_conditions


def get_hit_vocabulary(rule, vulnerability):
    sentences = rule["vocabulary"]
    hit_vocabulary = False
    for sentence in sentences:
        if "..." in sentence:
            parts = sentence.split("...")
            if parts[0] in vulnerability["desc"] and parts[1] in vulnerability["desc"]:
                hit_vocabulary = True
                break
        elif "?" == sentence:
            hit_vocabulary = True
            break
        elif sentence in vulnerability["desc"]:
            hit_vocabulary = True
            break
    return hit_vocabulary


def get_post_condition_from_rule(rule, vulnerability, post_condition, vulnerability_key):
    """Checks if it finds rule post-condition"""
    
    # Checks if the cpe in the rule is same with vulnerability.
    if rule["cpe"] != "?":
        if rule["cpe"] == "o" and vulnerability["cpe"] != "o":
            return post_condition
        elif rule["cpe"] == "h" and (vulnerability["cpe"] != "h" and vulnerability["cpe"] != "a"):
            return post_condition
    
    # Checks if the vocabulary is matching
    hit_vocabulary = get_hit_vocabulary(rule, vulnerability)
    if not hit_vocabulary:
        return post_condition
    
    # Check Impacts
    if rule["impacts"] == "ALL_COMPLETE":
        if vulnerability["attack_vec"]["I"] == "C" and vulnerability["attack_vec"]["C"] == "C":
            if vulnerability_key not in post_condition or \
                    post_condition[vulnerability_key] > get_privilege_value(rule["postcondition"]):
                post_condition[vulnerability_key] = get_privilege_value(rule["postcondition"])
    
    elif rule["impacts"] == "PARTIAL":
        
        if vulnerability["attack_vec"]["I"] == "P" or vulnerability["attack_vec"]["C"] == "P":
            if vulnerability_key not in post_condition or \
                    post_condition[vulnerability_key] > get_privilege_value(rule["postcondition"]):
                post_condition[vulnerability_key] = get_privilege_value(rule["postcondition"])
        
        else:
            if vulnerability_key not in post_condition or \
                    post_condition[vulnerability_key] > get_privilege_value(rule["postcondition"]):
                post_condition[vulnerability_key] = get_privilege_value(rule["postcondition"])
    
    elif rule["impacts"] == "ANY_NONE":
        if vulnerability["attack_vec"]["I"] == "N" or vulnerability["attack_vec"]["C"] == "N":
            if vulnerability_key not in post_condition or \
                    post_condition[vulnerability_key] > get_privilege_value(rule["postcondition"]):
                post_condition[vulnerability_key] = get_privilege_value(rule["postcondition"])
    
    return post_condition
